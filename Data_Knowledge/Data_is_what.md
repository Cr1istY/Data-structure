# 数据结构

*唯一可以确定的是，明天会使我们所有人大吃一惊。*

## 前言

### 为什么要学习数据结构

1. 学习数据结构能用程序代码把现实世界的问题信息化。
1. 能用高效的方法处理相关问题

### 用c语言表述现实的数

float - 浮点型 - 小数

X[ ] - 数组 - 排队问题

struct - 结构体 - 复杂的数组

## 第一章 绪论

### 第一节 数据

#### 什么是数据？

数据是**信息的载体**，是所有能输入到计算机中并被**计算机程序识别和处理**的符号的集合。
数据是计算机程序加工的**原料**。

#### 数据的分类

1. 数据元素 - 数据的基本单位 - 由数据项组成
1. 数据项 - 构成数据元素的不可分割之`最小单位`
1. 组合项 - 数据项中的多个更细分的属性（*若将生日看成一个数据项，则年、月、日为组合项*）
1. 数据对象 - **相同性质**的数据元素的集合
1. 数据结构 - **存在关系**的数据元素的集合

**学习数据结构，我们更多关注的是数据元素之间的`关系`，以及对关系的操作。**

#### 数据结构的三要素

1.
> 逻辑结构
>
> 1. 集合结构
> 2. 线性结构 - 一对一 - 除了第一个元素，每个元素都有唯一前驱，除了最后一个元素，每一个元素都有唯一后继
> 3. 树形结构 - 一对多 - 像树一样
> 4. 图状结构 - 多对多

2.
> 数据的运算
>
>1. 查找
>
>2. 插入
>
>3. 删除
>
>........

3.
> 物理结构（存储结构）
>
>如何在计算机中表示逻辑关系
>
>1. 顺序存储
>
>2. 链式存储
>
>3. 索引存储
>
>4. 散列存储
>

**运算的定义是针对逻辑结构来设计的，而运算的实现是针对存储结构实现的**。

### 第二节 算法

#### 什么是算法

程序 = 数据 + 算法

#### 算法的特性

1. 有穷性 - 步骤不是无穷的（程序的步骤可以无穷）
1. 确定性 - 相同的输入只能产生相同的输出
1. 可行性
1. 有输入
1. 有输出

#### 好的算法的特质

1. 正确解决问题
1. 可读性 - 易于看懂
1. 健壮性（鲁棒性） - 正确处理错误、非法的数据
1. 高效率及低存储需求 - 时间和空间复杂度较低

### 时间复杂度

*时间复杂度和空间复杂度标识了算法效率的质量*

时间复杂度：时间开销T(n)与问题规模n的函数关系

#### 是否可以忽略表达式中的某些部分：

答：取极限，只保留阶数最高的项。

##### 大O表示法：

大O表示“同阶”，同等数量级。

T(n) = O(n)

T(n^2^) = O(n^2^)

常 < 对 < 幂 < 指 < 阶

	void Loveyou(int n){
		int i = 1;
		while(i <= n){
			i++;
			printf("I Love u %d\n", i);

		}
		printf("I Love u more than %d\n", n);
	}

**顺序执行的代码只会影响常数项，可以省略**

**只需挑循环中的一个基本操作分析它的执行次数与n的关系**

**对于循环代码，若有多层嵌套循环，只需要关注最深层循环的循环次数**

最坏时间复杂度：最坏情况下算法的时间复杂度

平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望时间

### 空间复杂度

#### 程序运行时的内存需求

程序运行时，不论问题规模怎么变化，他的空间规模是固定的常量的。

空间的复杂度用 S(n) 表示。

算法原地工作 - 算法所需内存空间为常量。

#### 例子

一维数组 - S(n)

二维数组 - S(n^2^)

## 第二章 线性表

### 第一节 定义和基本操作（增删改查）

线性逻辑结构(前驱和后继)，具有`相同类型`的n个数据元素的`有限序列`，n为表长，当n=0是，为空表。

#### 基本操作

InitList(&L) : 初始化表

DestroyList(&L) : 销毁表

ListInsert(&L, i, e) : 插入

ListDelete(&L, i, &e) : 删除

按值查找

按位查找

#### 其他操作

求表长

输出

判空操作